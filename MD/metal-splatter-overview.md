# MetalSplatter Library Overview

Status: generated by Codex (2024-XX-XX) to capture the current architecture of the MetalSplatter Swift Package. Update this file whenever modules change to keep institutional knowledge current.

---

## Package Layout (`Package.swift`)
- Targets ship as standalone modules: `PLYIO`, `SplatIO`, `MetalSplatter`, `SampleBoxRenderer`, and the `SplatConverter` executable. `PLYIO`/`SplatIO` feed data to the renderer; `SampleBoxRenderer` is a debugging drop-in; `SplatConverter` is a CLI companion.
- Platform minimums: iOS 17 / macOS 14 / visionOS 1.0, with optional Metal 4 features gated behind Apple GPU family checks.

## PLYIO Module (PLYIO/Sources)
- Streaming readers/writers: `PLYReader.swift` uses an adaptive buffer, incremental header parsing, and a delegate API to emit `PLYElement`s from ASCII or binary files without loading everything into memory. `PLYWriter.swift` mirrors that functionality for writing.
- Rich type system: utility protocols (`BitPatternConvertible`, `ByteWidthProviding`, `DataConvertible`, `EndianConvertible`, `UnsafeRawPointerConvertible`, `ZeroProviding`) underpin `PLYHeader` / `PLYElement` encoding helpers (`PLYElement+ascii/binary`, `PLYHeader+ascii`).
- Tests (`PLYIO/Tests`) exercise both ASCII/binary round-trips with fixture data under `PLYIO/TestData`.

## SplatIO Module (SplatIO/Sources)
- Unified scene reader/writer API: `SplatSceneReader`, `SplatSceneWriter`, and `SplatScenePoint` capture position, rotation, SH color, opacity, etc. `SplatSceneReaderDelegate` delivers streaming callbacks to avoid huge allocations.
- Format coverage:
  - DotSplat (.splat) via `DotSplatSceneReader/Writer`.
  - Binary/ASCII PLY with `SplatPLYSceneReader/Writer` (reuses `PLYIO` and `SplatPLYConstants` for attribute ordering).
  - SOGS (.meta.json + textures) v1/v2 with `SplatSOGSSceneReader`, `SplatSOGSSceneReaderOptimized`, `SplatSOGSSceneReaderV2`, and `SOGSMetadata*` data models. Readers decode WebP atlases via `WebPDecoder`, cache compressed planes through `SOGSTextureCache`, and validate metadata.
  - Packed Luma/NeRF exports: `.spz` and `.spx` handled by `SPZ*` / `SPX*` readers & writers using `SPZPackedTypes.swift`, `SPXPackedTypes.swift`, plus `DataCompression` helpers.
  - Zip containers (`SplatSOGSZipReader`), `.sog` bundles, and autodetection via `AutodetectSceneReader.swift`.
- Reliability utilities: `SplatDataValidator`, `SplatValidationError`, `SplatMemoryBuffer` (CPU staging), `SplatScenePoint+CustomStringConvertible` for diagnostics.
- Tests and fixture data live under `SplatIO/Tests` and `SplatIO/TestData`.

## MetalSplatter Module (MetalSplatter/Sources)

### Core Renderer (`SplatRenderer.swift`)
- Public API wraps Metal state (device, formats, sample count, multi-view) with error types and lifecycle hooks (`onSortStart`, `onRenderComplete`, etc.).
- Multi-stage vs single-stage pipelines: uses per-tile imageblock memory (`MultiStageRenderPath.metal`) when `highQualityDepth` and depth writes are enabled, falling back to `SingleStageRenderPath.metal` otherwise. Pipeline creation happens lazily (`buildSingleStagePipelineState`, `buildInitializePipelineState`, etc.).
- Sorting & LOD: stores splats in double-buffered `MetalBuffer<Splat>` pools, sorts by either Euclidean distance or forward vector, and exposes LOD constants (`maxRenderDistance`, `lodSkipFactors`). `prepareForSorting` / `appendSplatForSorting` allow subclasses (e.g., Fast SH) to shadow the buffer swap.
- Loading: `read(from:)` uses `SplatMemoryBuffer` + `AutodetectSceneReader` to ingest any supported format asynchronously.
- Viewport handling: `ViewportDescriptor` packs projection/view matrices plus target screen sizes to drive vertex amplification (stereo support).

### GPU Infrastructure
- `MetalBuffer.swift` / `MetalBufferPool.swift`: typed CPU-mapped ring buffers with exponential growth, pooling, and safety checks against `device.maxBufferLength`.
- `CommandBufferManager` + `Metal4CommandBufferPool.swift`: optional Metal 4 command-buffer reuse (with legacy fallback) plus stats/memory-pressure hooks.
- `MetalBuffer` derivatives: `Metal4ArgumentBufferManager.swift` builds real `MTLArgumentEncoder` layouts to bind splat/uniform/index buffers once per frame; `Metal4BindlessArchitecture.swift` layers residency tracking, background population, and handle management for Apple GPU family 7+.
- `SplatRenderer+Metal4Simple.swift`, `SplatRenderer+BindlessIntegration.swift`, and `SplatRenderer+Metal4Integration.swift` hook those managers into the draw path (SIMD/tensor compute preprocessing, argument-buffer binding, “renderWithBindless” zero bind calls). All availability-gated via `#available` + `supportsFamily`.
- `Metal4ArgumentBufferManager` exposes stats, residency set updates, and per-command-buffer binding helpers; `Metal4BindlessArchitecture` registers buffers/textures, populates bindless tables, and tracks residency handles.
- `MPSArgSort.swift`: lightweight wrapper around MPSGraph arg-sort for GPU-based index sorting.
- `GPUPerformanceProfiler.swift`: synthetic kernels to benchmark compute paths (distance calculation, memory bandwidth) and compare optimizations.

### Rendering Extensions
- `SplatRenderer+Metal4Integration.swift`: compute stage (SIMD-group vs tensor operations) that preprocesses splats before the render pass on Apple GPU family 9+ devices.
- `SplatRenderer+BindlessIntegration.swift`: registers existing buffers with the bindless architecture and drives the render pass without `setBuffer` calls, including residency updates per viewport.
- `SplatRenderer+Metal4Simple.swift`: public entry points for enabling/disabling argument-buffer-based bindless rendering and reporting stats, plus helper metrics struct.
- `SplatRenderer+FastSH.swift` / `FastSHSplatRenderer`: extends the renderer with palette-based SH evaluation (per-splat SH metadata, palette buffers, `FastSHRenderPath.metal`), buffer pooling, and support for loading `SplatScenePoint` arrays that carry SH coefficients. Includes compatibility shims for `ModelRendererViewportDescriptor`.
- `FastSHExample.swift`: sample orchestration code showing how to configure `FastSHSplatRenderer`, load data via `SplatIO`, and render multiple viewports.
- `SphericalHarmonicsEvaluator.swift` (under `MetalSplatter/Sources/MetalSplatter`) mirrors the Metal helper (`spherical_harmonics_evaluate.metal`) for CPU-side SH palette work.

### AR Integration
- `ARSplatRenderer.swift`: wraps `ARSession`, `ARBackgroundRenderer`, and `ARPerspectiveCamera` to render splats directly into ARKit camera feeds. Provides placement controls (position/scale/rotation), coordinate calibration for SOGS v2 files, asynchronous auto-placement heuristics, and optional Metal 4 bindless/MPP enhancements.
- `ARBackgroundRenderer.swift`: renders the camera feed to Metal textures, handling `ARFrame` updates.
- `ARPerspectiveCamera.swift`: derives projection/view matrices and exposes convenience accessors for viewport configuration.
- Additional AR-specific Metal shaders live next to the rest of the resources (`ARMetal4Enhancements.metal`).

### Utilities & Instrumentation
- `GPUPerformanceProfiler.swift` and `Metal4PerformanceMetrics` support profiling and reporting improvements from Metal 4 optimizations (depth compute, cache hit rates, etc.).
- `MetalBufferPool` tracks buffer age/memory pressure, releasing stale buffers automatically.
- Logging performed via `os.Logger` in every subsystem for observability.

## Shader Resources (`MetalSplatter/Resources`)
- Core render paths: `SingleStageRenderPath.metal`, `MultiStageRenderPath.metal`, `SplatProcessing.metal`, `ComputeDistances.metal`, `FrustumCulling.metal`.
- Metal 4 experiments: `Metal4SIMDGroupOperations.metal`, `Metal4TensorOperations.metal`, `Metal4MeshShaders.metal`, `Metal4ArgumentBuffer.metal`, `Metal4AdvancedAtomics.metal`, `Metal4BindlessShaders.metal`, `ARMetal4Enhancements.metal`.
- Fast SH + SH helpers: `FastSHRenderPath.metal`, `spherical_harmonics_evaluate.metal`, shared structs/constants defined in `ShaderCommon.h` / `SplatProcessing.h`.

## SampleBoxRenderer Target
- `SampleBoxRenderer/Sources/SampleBoxRenderer.swift` implements the same API surface as `SplatRenderer` but renders a canonical cube (matching Apple’s Metal template). Useful for integration debugging without splat assets; uses its own `.metal` shaders under `SampleBoxRenderer/Resources`.

## Tooling & Sample App
- `SplatConverter` (`SplatConverter/Sources/SplatConverter.swift`): CLI built with `swift-argument-parser`. Reads any supported format via `AutodetectSceneReader`, filters slices (`--start`, `--count`), optionally prints splat descriptions, and writes `.splat`, `.ply` (binary/ASCII) using the appropriate writer.
- `SampleApp/MetalSplatter_SampleApp.xcodeproj`: minimal iOS/macOS/visionOS demo that wires `MetalSplatter` into Apple’s Metal template, showcasing loading/rendering plus camera controls. Release configuration recommended for performance.
- `SampleBoxRenderer` can replace `MetalSplatter` in the sample app for sanity checks.
- Example assets (`skull.sog`, `External_Reference/`) and documentation stubs (`MD/`) accompany the repo.

## Data Flow Summary
1. **Import**: `SplatRenderer.read(from:)` hands a URL to `SplatIO.AutodetectSceneReader`, which streams points through `SplatMemoryBuffer`.
2. **CPU staging**: Points are packed into `MetalBuffer<Splat>` objects (with optional Fast SH metadata).
3. **GPU prep**: Distances/indices computed (`ComputeDistances.metal`, `MPSArgSort`, optional Metal 4 compute preprocess & frustum cull).
4. **Rendering**: Single- or multi-stage pipelines draw quads per splat, optionally storing higher-quality depth. Bindless/argument-buffer paths minimize CPU binding overhead. Diagnostics and performance callbacks report timing.
5. **AR** (optional): `ARSplatRenderer` composites splats with camera feeds and handles placement/tracking across AR session states.

## Follow‑ups / Watch Areas
- Metal 4 APIs are guarded by availability but many files contain placeholder logging; keep tests/devices on recent SDKs to shake out bugs.
- SOGS handling spans multiple reader versions (v1, v2, optimized) – ensure changes to metadata schemas update all relevant structs (`SOGSMetadata*`) and readers/writers simultaneously.
- Fast SH pipeline relies on matching SH palettes between CPU (`SphericalHarmonicsEvaluator.swift`) and GPU (`FastSHRenderPath.metal`); changes to coefficient ordering must be reflected in both locations.
- `Metal4BindlessArchitecture` / `SplatRenderer+BindlessIntegration` store bindless state via associated objects – revisit ownership if you add multiple renderer instances.

Keep this document synchronized with code changes (new formats, shaders, or rendering paths) so future contributors can ramp up quickly.
